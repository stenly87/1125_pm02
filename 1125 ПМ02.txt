ПМ02 Ревьюирование программных модулей
профессиональный модуль

Жизненный цикл ПО начинается с некоторой идеи или задачи,
завершается при потере необходимости в данном ПО

Примерные стадии ЖЦ:
1. Идея
2. Проектирование - 60% времени разработки
3. Разработка
4. Тестирование
5. Внедрение
6. Эксплуатация
7. Завершение эксплуатации и жизни ПО

Виды ЖЦ ПО:
1. Водопадный (Каскадный) ЖЦ
2. Водопадный (Каскадный) ЖЦ c возвратом
3. Спиральный (Циклический) ЖЦ
4. V-образный - Rational roze

Спиральный (Циклический):
Предполагает, что на каждом витке создается новая версия
программного обеспечения (это может быть обновление либо
переделка ПО с нуля). Цикл может продолжаться бесконечно.

На этапе проектирования выясняется следующее:
1) Требования заказчика (требования к функционалу, интерфейсу, виду и хранению данных, отказоустойчивости,
запрещенный функционал)
2) Сбор требований происходит с разных пользователей системы (директор, менеджер, конечные пользователи)
3) Разработка макета или тестового проекта - помогает
выявить проблемы в проектировании, оценить сложность
разработки, внести коррективы в требования, позволяют
пользователям понять, чего ждать от ПО
4) Итогом этапа проектирования обычно является несколько 
документов, в которых подробно расписаны все требования,
примеры алгоритмов (или точные реализации), схемы, модули
Эти документы должны быть подписаны заказчиком
Техническое задание

Существует много видов ПО:
Поисковые информационные системы (ИС, АИС) (поиск по некоторой базе знаний)
Библиотечные ис (хранение данных)
Вычислительные ис (математические вычисления, исследования)
Развлекательное ПО
Операционные системы и прикладное ПО (драйвера и другие низкоуровневые приложения)
Системы разработки

Автоматические ис - нет контролера (персонала)
Автоматизированные ис - есть управляющий

информационная система предназначения для хранения, обработки, ввода/вывода данных с определенной целью.

информационная система состоит из некоторого ПО, работающего на некоторой ОС, из оборудования и персонала, который управляет и обслуживает оборудование и ПО.

Основными частями ПО обычно являются:
1) система ввода (способов ввода данных может быть много:
от ввода вручную с помощью интерфейса и импорта файлов до отслеживания датчиков и/или событий ОС)
2) система вывода информации (интерфейс пользователя также может быть довольно разным - может предполагать наличие кнопок/списков и тп, может быть в виде api-сервиса,
или консоли/файла с логом и тп)
3) система хранения данных (субд, файлы, сети и тп)
4) ряд систем обработки данных
5) система логирования
6) система резервирования

ГИТ (git) - протокол, по которому работает система контроля изменений в проекте. Система контроля версий.
Система контроля версий нужна для нескольких вещей:
1) сохранение работы в любой момент времени
2) возможность возвращения к разным сохраненным моментам 
работы над проектом
3) за счет пункта 2, мы не боимся вносить изменения в проект (в код), поскольку всегда можно вернуться в стабильное состояние (на сохраненный коммит)
4) использование гит позволяет работать над проектом в команде

Установка и настройка git
1) Скачиваем и устанавливаем приложение с сайта https://git-scm.com/
2) Здесь документация к командам: https://git-scm.com/docs

Репозиторий - это директория, изменения в которой отслеживаются системой git
В репозитории создается скрытая папка .git, в которой фиксируются все локальные коммиты. Это локальный репозиторий. Если его удалить, то история потеряется, директория больше не будет отслеживаться

Каждая зафиксированная точка в репозитории называется коммитом. Это точка, которая сохраняет состояние всех отслеживаемых файлов в директории. Для создание следующей точки необходимо внести изменения в файлы.
В репозитории можно настроить игнорирование некоторых файлов и/или вложенных директорий, для того, чтобы не отслеживать изменения в них, за это отвечает файл .gitignore в корне директории.

Сразу после установки следует настроить пару параметров в git
Следует обязательно задать имя (User Name) и почту (Email Address)
Эта информация используется при создании коммита. Получается, что все изменения подписываются их авторами.
Во время инсталяции важно поменять хотя бы текстовый редактор, остальное станет ясным по мере работы с git

Создание репозитория производится командой git init в консоли
Посмотреть, есть ли изменения в папке можно командой git status
Для добавления изменений в коммит используется команда git add
команда с точкой (git add .) позволяет добавить в коммит все изменения, которые есть, сразу
После того, как набор файлов для коммита определен
Можно создать сам коммит, при этом обязательно к нему нужно добавить
комментарий (либо пишем git commit, либо git commit -m "комментарий")
После этого коммит будет создан в локальном репозитории, он будет отображаться в истории и к нему можно будет вернуться (откатить изменения во всех файлах репозитория к этому состоянию)
Команда для просмотра истории - git log
Для создания удаленного репозитория, нам нужно сначала определиться с удаленным сервером (github, gitlab, bitbucket или какой-то кастомный вариант), на удаленном сервере создается репозиторий, путь к нему копируется для добавления ссылки на удаленный репозиторий в нашем локальном репозитории
Для добавления ссылки на удаленный репозиторий используется git remote
Пример:
git remote add remote_master https://github.com/stenly87/test_rep_0909.git
Дальше нужно сделать первую синхронизацию с удаленным репозиторием
git push -u remote_master master
Изменения будут залиты в удаленный репозиторий, при условии, что у нас есть доступ и текущий компьютер авторизован в гитхабе
Авторизация с гитхабом в windows хранится в аплете
Панель управления\Все элементы панели управления\Диспетчер учетных данных
еще несколько команд:
git restore - позволяет восстановить изменения в файле до последнего проиндексированного состояния
git restore --staged - позволяет убрать файл из создаваемого коммита
git rm - позволяет удалить отслеживаемый файл из индекса и репозитория
git rm --cached - удаление файла из индекса, но в репозитории файл останется

git reset  - возможные аргументы --soft, --mixed и --hard.
после аргументов указывается хэш коммита, к которому нужно "откатиться", аргумент hard - восстанавливает физическую структуру репозитория в соответствии с указанным коммитом

гит поддерживает работу с разными ветками, которые можно создать на любом коммите. У созданной ветки идет своя история коммитов, которая при удачном завершении может быть подвержена слиянию (слита) с основной веткой репозитория (либо веткой отвечающей за текущую разрабатываемую версию).
Получается, что каждый разработчик в команде, получив задание на разработку некоторого дополнения, может создать свою ветку и спокойно работать в ней, пока не выполнит свою работу. Дальше эта ветка сливается с рабочей веткой, перенося в нее новый функционал. Это действие может быть произведено с дополнительной работой над решением конфликтов между одноименными файлами из разных веток.

за работу с ветками отвечают команды git branch , git checkout, git branch -d, git merge

git branch имя - создание новой ветки относительного того коммита, на котором мы сейчас находимся
git checkout имя - переключиться на указанную ветку, при этом репозиторий физически перестраивается на сооветствие этой ветке
git merge имя - позволяет произвести слияние двух веток, в текущую добавляются изменения из указанной
git branch -d имя - удаление ветки (как правило после слияния)
при удалении ветки, мы должны находиться в другой ветке

для отправки и получения данных из удаленных репозиториев 
используются команды git push (отправка) и git pull (получение изменений)
git push - берет все неотправленные коммиты и пытается их отправить в удаленный репозиторий. Если на удаленном репозитории в той ветке, куда мы пытаемся залить наши коммиты, уже есть новые коммиты, которых нет у нас - мы получим ошибку. Нам нужно сначала получить все последние изменения, только после этого можно будет залить свои изменения.
Получение изменений из удаленного репозитория выполняется командой git pull - команда выполняет 2 других команды гита: git getch (получить изменения) и git merge или rebase (слияние удаленных изменений с локальным репозиторием). Если в локальном репозитории при этом уже есть какие-то конфликтные изменения - то придется разрешить эти конфликты (создать новый коммит)
Когда репозиторий переходит в состояние разрешения конфликтов в текстовых файлах появляются пометки у конфликтов, которые нам надо решить. Мы можем убрать эти пометки, отменив слияние
командой git merge --abort - локальный репозиторий возвращается в состояние, которые было до слияния.